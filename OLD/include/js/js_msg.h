#ifndef JS_MSG_H
#define JS_MSG_H

/* This file generated by genmsg on 2010-03-29T12:00:20, host giskard, probably by user jscholz */
/* You are hereby discouraged from editing it directly */

typedef struct {
    uint32_t axes_fill;
    uint32_t axes_max;
    double *axes;
    int32_t buttons;
} js_msg_t;
static void js_msg_init(js_msg_t *val);
static void js_msg_destroy(js_msg_t *val);
static int js_msg_size(js_msg_t *val);
static int js_msg_data_size(js_msg_t *val);
static int js_msg_encode(void *buf, int n, js_msg_t *val);
static int js_msg_decode(js_msg_t *val, void *buf, int n);
static int js_msg_encode_data(void *buf, int n, js_msg_t *val);
static int js_msg_decode_data(js_msg_t *val, void *buf, int n);
static char js_msg_typecode_str[] = "JS-MSG{AXES:DOUBLE *;BUTTONS:INT32}";
static uint8_t js_msg_typecode[16] =
    {228, 95, 206, 227, 12, 143, 34, 32, 102, 5, 231, 106, 196, 219, 162, 74};
static void js_msg_init(js_msg_t *val) {
    val->axes_fill = 0;
    val->axes_max = 0;
    val->axes = NULL;
    int32_init(&val->buttons);
}
static void js_msg_destroy(js_msg_t *val) {
    if( NULL != val->axes ) free(val->axes);
    int32_destroy(&val->buttons);
}
static int js_msg_size(js_msg_t *val) {
    return 16 + js_msg_data_size(val);
}
static int js_msg_data_size(js_msg_t *val) {
    int m = 0;
    m += sizeof(uint32_t);
     {
        int j;
        for( j = 0; j < val->axes_fill; j++ ) {
            m += double_data_size(&val->axes[j]);
        }
    }
    m += int32_data_size(&val->buttons);
    return m;
}
static int js_msg_encode(void *buf, int n, js_msg_t *val) {
    if( js_msg_size(val) > n ) return GENMSG_EOVERFLOW;
    memcpy(buf, js_msg_typecode, 16);
    int i = js_msg_encode_data((&((char*)buf)[16]), n-16, val);
    return (i > 0) ? (i + 16) : i;
}
static int js_msg_encode_data(void *buf, int n, js_msg_t *val) {
    int i = 0;
    int32_t r;
    /* check size */
    if( js_msg_data_size(val) > n ) return GENMSG_EOVERFLOW;
    /* Encode slot axes */
    r = uint32_encode_data((&((char*)buf)[i]), n - i, &val->axes_fill);
    if( r <= 0 ) return r; else i += r;
     {
        int j;
        for( j = 0; j < val->axes_fill; j++ ) {
            r = double_encode_data((&((char*)buf)[i]), n - i, &val->axes[j]);
            if( r <= 0 ) return r; else i += r;
        }
    }
    /* Encode slot buttons */
    r = int32_encode_data((&((char*)buf)[i]), n - i, &val->buttons);
    if( r <= 0 ) return r; else i += r;
    return i;
}
static int js_msg_decode(js_msg_t *val, void *buf, int n) {
    if( 0 != memcmp( buf, js_msg_typecode, 16 ) ) return GENMSG_ETYPECODE;
    int i = js_msg_decode_data(val, (&((char*)buf)[16]), n-16);
    return (i > 0) ? (i + 16) : i;
}
static int js_msg_decode_data(js_msg_t *val, void *buf, int n) {
    int i = 0;
    uint32_t r;
    /* Decode axes */
     {
        uint32_t size;
        r = uint32_decode_data(&size, (&((char*)buf)[i]), n - i);
        if( r <= 0 ) return r; else i += r;
        if ( size > val->axes_max ) return GENMSG_EOVERFLOW;
        val->axes_fill = size;
         {
            int j;
            for( j = 0; j < size; j++ ) {
                r = double_decode_data(&val->axes[j], (&((char*)buf)[i]), n - i);
                if( r <= 0 ) return r; else i += r;
            }
        }
    }
    /* Decode buttons */
    r = int32_decode_data(&val->buttons, (&((char*)buf)[i]), n - i);
    if( r <= 0 ) return r; else i += r;
    return i;
}
#endif
